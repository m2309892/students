{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Лекция: Создание API для управления студентами с FastAPI и PostgreSQL (v2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Введение\n",
    "\n",
    "**Цель проекта:** Разработка REST API для управления информацией о студентах университета. API позволяет добавлять, получать, обновлять и удалять данные о студентах.\n",
    "\n",
    "**Стек технологий:**\n",
    "\n",
    "*   **FastAPI:** Современный, быстрый (высокопроизводительный) веб-фреймворк для создания API на Python 3.8+, основанный на стандартных подсказках типов Python.\n",
    "*   **PostgreSQL:** Мощная, объектно-реляционная система управления базами данных (СУБД) с открытым исходным кодом.\n",
    "*   **SQLAlchemy:** Библиотека ORM (Object-Relational Mapper) для Python, которая предоставляет удобный способ взаимодействия с реляционными базами данных.\n",
    "*   **Pydantic:** Библиотека для валидации данных и управления настройками с использованием аннотаций типов Python.\n",
    "*   **Uvicorn:** ASGI (Asynchronous Server Gateway Interface) сервер, необходимый для запуска асинхронных веб-приложений, таких как FastAPI."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. PostgreSQL\n",
    "\n",
    "**Что это?** Реляционная база данных, где данные хранятся в таблицах со строками и столбцами. PostgreSQL известна своей надежностью, гибкостью и поддержкой стандартов SQL.\n",
    "\n",
    "**Роль в проекте:** Хранит всю информацию о студентах (имя, фамилия, email, телефон, факультет, курс).\n",
    "\n",
    "**Установка (Windows):**\n",
    "\n",
    "1.  **Скачать:** Перейдите на [официальный сайт PostgreSQL](https://www.postgresql.org/download/windows/) и скачайте установщик для вашей версии Windows.\n",
    "2.  **Установить:** Запустите установщик.\n",
    "    *   **Компоненты:** Оставьте выбранные по умолчанию (PostgreSQL Server, pgAdmin 4, Command Line Tools).\n",
    "    *   **Директория данных:** Можете оставить по умолчанию.\n",
    "    *   **Пароль:** Задайте надежный пароль для суперпользователя `postgres`. **Запомните или запишите его!**\n",
    "    *   **Порт:** Оставьте порт по умолчанию `5432`.\n",
    "    *   **Локаль:** Выберите региональные настройки или оставьте `Default locale`.\n",
    "3.  **Завершение:** Дождитесь окончания установки. Можно снять галочку \"Launch Stack Builder\".\n",
    "4.  **pgAdmin:** Найдите и запустите `pgAdmin 4` через меню \"Пуск\". Это графический инструмент для управления базами данных PostgreSQL. При первом запуске может потребоваться задать мастер-пароль для pgAdmin (это не тот же пароль, что для пользователя `postgres`).\n",
    "5.  **Создание БД:**\n",
    "    *   В pgAdmin подключитесь к серверу (введите пароль пользователя `postgres`, заданный при установке).\n",
    "    *   Найдите \"Databases\", щелкните правой кнопкой мыши → \"Create\" → \"Database...\".\n",
    "    *   Введите имя базы данных: `university_db`.\n",
    "    *   Нажмите \"Save\".\n",
    "6.  **Переменные среды (PATH):** Для удобства использования утилиты `psql` из командной строки, добавьте путь к папке `bin` вашей установки PostgreSQL (например, `C:\\\\Program Files\\\\PostgreSQL\\\\16\\\\bin`) в системную переменную PATH.\n",
    "\n",
    "**Конфигурация в проекте (`.env`):**\n",
    "Файл `.env` хранит URL для подключения к базе данных."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "execution_count": null,
   "source": [
    "# Пример содержимого файла .env\n",
    "# DATABASE_URL=postgresql://ПОЛЬЗОВАТЕЛЬ:ПАРОЛЬ@ХОСТ:ПОРТ/ИМЯ_БД\n",
    "# Например:\n",
    "# DATABASE_URL=postgresql://postgres:mypassword@localhost:5432/university_db"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. SQLAlchemy\n",
    "\n",
    "**Что это?** ORM - инструмент, который позволяет работать с базой данных, используя объекты Python вместо написания SQL-запросов вручную. Он \"переводит\" операции с объектами Python в SQL-команды.\n",
    "\n",
    "**Роль в проекте:**\n",
    "\n",
    "*   **`models.py`:** Определяет структуру таблиц базы данных с помощью классов Python.\n",
    "*   **`database.py`:** Настраивает подключение и предоставляет сессии для взаимодействия с БД."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Пример из `models.py`"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "execution_count": null,
   "source": [
    "# Содержимое файла models.py:\n",
    "\n",
    "from sqlalchemy import Column, Integer, String, create_engine\n",
    "from sqlalchemy.ext.declarative import declarative_base\n",
    "from sqlalchemy.orm import sessionmaker\n",
    "import os\n",
    "from dotenv import load_dotenv\n",
    "\n",
    "load_dotenv() # Загрузка переменных из .env файла\n",
    "\n",
    "DATABASE_URL = os.getenv(\"DATABASE_URL\") # Получаем URL из окружения\n",
    "\n",
    "engine = create_engine(DATABASE_URL) # Создаем 'движок' SQLAlchemy\n",
    "# Создаем фабрику сессий\n",
    "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n",
    "\n",
    "Base = declarative_base() # Базовый класс для всех моделей\n",
    "\n",
    "# Определение модели (таблицы) Student\n",
    "class Student(Base):\n",
    "    __tablename__ = \"students\" # Имя таблицы в БД\n",
    "\n",
    "    # Определение столбцов таблицы\n",
    "    id = Column(Integer, primary_key=True, index=True)\n",
    "    first_name = Column(String, nullable=False)\n",
    "    last_name = Column(String, nullable=False)\n",
    "    email = Column(String, unique=True, nullable=False)\n",
    "    phone = Column(String) # nullable=True по умолчанию\n",
    "    faculty = Column(String, nullable=False)\n",
    "    course = Column(Integer, nullable=False)\n",
    "\n",
    "# Создание всех таблиц, описанных в моделях (если их нет)\n",
    "# Эта строка выполняется при импорте models.py, обычно при старте приложения\n",
    "# Base.metadata.create_all(bind=engine) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Пример из `database.py`"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "execution_count": null,
   "source": [
    "# Содержимое файла database.py:\n",
    "\n",
    "from sqlalchemy import create_engine\n",
    "from sqlalchemy.ext.declarative import declarative_base\n",
    "from sqlalchemy.orm import sessionmaker\n",
    "import os\n",
    "from dotenv import load_dotenv\n",
    "\n",
    "load_dotenv() # Загрузка переменных\n",
    "\n",
    "DATABASE_URL = os.getenv(\"DATABASE_URL\") # Получаем URL\n",
    "\n",
    "engine = create_engine(DATABASE_URL) # Создаем движок\n",
    "# Создаем фабрику сессий\n",
    "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n",
    "\n",
    "Base = declarative_base() # Базовый класс (можно импортировать из models)\n",
    "\n",
    "# Функция-генератор для получения сессии БД\n",
    "# Используется как зависимость в FastAPI\n",
    "def get_db():\n",
    "    db = SessionLocal() # Создаем экземпляр сессии\n",
    "    try:\n",
    "        yield db # Предоставляем сессию эндпоинту\n",
    "    finally:\n",
    "        db.close() # Гарантированно закрываем сессию после использования\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Pydantic\n",
    "\n",
    "**Что это?** Библиотека для парсинга и валидации данных. Она использует аннотации типов Python для определения ожидаемой структуры данных.\n",
    "\n",
    "**Роль в проекте (`schemas.py`):** Определяет ожидаемую структуру данных для входящих запросов и исходящих ответов."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Пример из `schemas.py`"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "execution_count": null,
   "source": [
    "# Содержимое файла schemas.py:\n",
    "\n",
    "from pydantic import BaseModel, EmailStr\n",
    "from typing import Optional\n",
    "\n",
    "# Базовая схема студента (общие поля)\n",
    "class StudentBase(BaseModel):\n",
    "    first_name: str\n",
    "    last_name: str\n",
    "    email: EmailStr # Pydantic автоматически валидирует email\n",
    "    phone: Optional[str] = None # Поле не обязательное\n",
    "    faculty: str\n",
    "    course: int\n",
    "\n",
    "# Схема для создания студента (наследуется от базовой)\n",
    "# Используется для валидации данных в POST запросах\n",
    "class StudentCreate(StudentBase):\n",
    "    pass # Нет дополнительных полей\n",
    "\n",
    "# Схема для обновления студента (все поля необязательные)\n",
    "# Используется для валидации данных в PUT запросах\n",
    "class StudentUpdate(BaseModel): # Не наследуется, т.к. все поля Optional\n",
    "    first_name: Optional[str] = None\n",
    "    last_name: Optional[str] = None\n",
    "    email: Optional[EmailStr] = None\n",
    "    phone: Optional[str] = None\n",
    "    faculty: Optional[str] = None\n",
    "    course: Optional[int] = None\n",
    "\n",
    "# Схема для возврата данных клиенту (включает id)\n",
    "# Используется как response_model в FastAPI\n",
    "class Student(StudentBase):\n",
    "    id: int\n",
    "\n",
    "    # Конфигурация для совместимости с SQLAlchemy ORM моделями\n",
    "    # Позволяет Pydantic читать данные из атрибутов объекта, а не только из dict\n",
    "    class Config:\n",
    "        from_attributes = True\n",
    "\n",
    "# --- Пример использования Pydantic для валидации --- \n",
    "try:\n",
    "    valid_data = {\n",
    "        \"first_name\": \"Иван\",\n",
    "        \"last_name\": \"Петров\",\n",
    "        \"email\": \"ivan.petrov@example.com\",\n",
    "        \"faculty\": \"Информатика\",\n",
    "        \"course\": 2\n",
    "    }\n",
    "    student_to_create = StudentCreate(**valid_data)\n",
    "    print(f\"Данные для создания валидны: {student_to_create.model_dump_json(indent=2)}\")\n",
    "\n",
    "    invalid_data = {\n",
    "        \"first_name\": \"Анна\",\n",
    "        \"last_name\": \"Сидорова\",\n",
    "        \"email\": \"anna.sidorova@\", # Невалидный email\n",
    "        \"faculty\": \"Филология\",\n",
    "        # Пропущено обязательное поле 'course'\n",
    "    }\n",
    "    print(\"\nПопытка валидации неполных/неверных данных:\")\n",
    "    student_invalid = StudentCreate(**invalid_data)\n",
    "except Exception as e:\n",
    "    print(f\"\nОшибка валидации: {e}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. FastAPI\n",
    "\n",
    "**Что это?** Высокопроизводительный веб-фреймворк для создания API.\n",
    "\n",
    "**Роль в проекте (`main.py`):** Определяет эндпоинты (маршруты) API и логику их обработки."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Пример из `main.py`"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "execution_count": null,
   "source": [
    "# Содержимое файла main.py (основные части):\n",
    "\n",
    "from fastapi import FastAPI, Depends, HTTPException\n",
    "from sqlalchemy.orm import Session\n",
    "from typing import List\n",
    "\n",
    "# Импорт моделей, схем и функции get_db (предполагается, что они доступны)\n",
    "from models import Student as StudentModel # Переименовываем, чтобы избежать конфликта\n",
    "from schemas import StudentCreate, StudentUpdate, Student as StudentSchema\n",
    "from database import get_db\n",
    "\n",
    "# Создаем экземпляр FastAPI\n",
    "app = FastAPI(title=\"University API\")\n",
    "\n",
    "# --- Эндпоинт POST /students/ --- \n",
    "@app.post(\"/students/\", response_model=StudentSchema)\n",
    "# student: StudentCreate - FastAPI автоматически валидирует тело запроса с помощью Pydantic\n",
    "# db: Session = Depends(get_db) - FastAPI вызывает get_db() и передает сессию в параметр db\n",
    "# response_model=StudentSchema - FastAPI валидирует и сериализует ответ с помощью Pydantic\n",
    "def create_student(student: StudentCreate, db: Session = Depends(get_db)):\n",
    "    # Создаем объект SQLAlchemy модели из данных Pydantic схемы\n",
    "    db_student = StudentModel(**student.model_dump())\n",
    "    db.add(db_student) # Добавляем в сессию\n",
    "    db.commit() # Сохраняем изменения в БД\n",
    "    db.refresh(db_student) # Обновляем объект из БД (чтобы получить id)\n",
    "    return db_student # Возвращаем объект SQLAlchemy, FastAPI сам его сериализует\n",
    "\n",
    "# --- Эндпоинт GET /students/ --- \n",
    "@app.get(\"/students/\", response_model=List[StudentSchema])\n",
    "# skip, limit - параметры запроса для пагинации ( /students/?skip=0&limit=10 )\n",
    "def get_students(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n",
    "    # Запрос к БД с помощью SQLAlchemy\n",
    "    students = db.query(StudentModel).offset(skip).limit(limit).all()\n",
    "    return students # Возвращаем список объектов SQLAlchemy\n",
    "\n",
    "# --- Эндпоинт GET /students/{student_id} --- \n",
    "@app.get(\"/students/{student_id}\", response_model=StudentSchema)\n",
    "# student_id: int - параметр пути ( /students/123 )\n",
    "def get_student(student_id: int, db: Session = Depends(get_db)):\n",
    "    student = db.query(StudentModel).filter(StudentModel.id == student_id).first()\n",
    "    if student is None:\n",
    "        # Если не найдено, возвращаем ошибку 404\n",
    "        raise HTTPException(status_code=404, detail=\"Student not found\")\n",
    "    return student\n",
    "\n",
    "# --- Эндпоинт PUT /students/{student_id} --- \n",
    "@app.put(\"/students/{student_id}\", response_model=StudentSchema)\n",
    "def update_student(student_id: int, student: StudentUpdate, db: Session = Depends(get_db)):\n",
    "    db_student = db.query(StudentModel).filter(StudentModel.id == student_id).first()\n",
    "    if db_student is None:\n",
    "        raise HTTPException(status_code=404, detail=\"Student not found\")\n",
    "    \n",
    "    # Получаем данные для обновления из Pydantic схемы\n",
    "    # exclude_unset=True - чтобы обновлять только переданные поля\n",
    "    update_data = student.model_dump(exclude_unset=True)\n",
    "    for key, value in update_data.items():\n",
    "        setattr(db_student, key, value) # Обновляем атрибуты объекта SQLAlchemy\n",
    "    \n",
    "    db.commit() # Сохраняем изменения\n",
    "    db.refresh(db_student) # Обновляем объект\n",
    "    return db_student\n",
    "\n",
    "# --- Эндпоинт DELETE /students/{student_id} --- \n",
    "@app.delete(\"/students/{student_id}\", status_code=200) # Указываем статус успешного удаления\n",
    "def delete_student(student_id: int, db: Session = Depends(get_db)):\n",
    "    student = db.query(StudentModel).filter(StudentModel.id == student_id).first()\n",
    "    if student is None:\n",
    "        raise HTTPException(status_code=404, detail=\"Student not found\")\n",
    "    \n",
    "    db.delete(student) # Удаляем из сессии\n",
    "    db.commit() # Сохраняем изменения в БД\n",
    "    # Возвращаем сообщение об успехе (FastAPI преобразует dict в JSON)\n",
    "    return {\"message\": \"Student deleted successfully\"} \n",
    "\n",
    "# Этот файл нужно запускать с помощью Uvicorn, а не напрямую.\n",
    "# Пример команды: uvicorn main:app --reload"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Uvicorn\n",
    "\n",
    "**Что это?** ASGI-сервер, необходимый для запуска FastAPI.\n",
    "\n",
    "**Роль в проекте:** Запускает приложение FastAPI и обрабатывает входящие HTTP-запросы.\n",
    "\n",
    "**Команда запуска (в терминале, не в ноутбуке):**"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "outputs": [],
   "execution_count": null,
   "source": [
    "# uvicorn main:app --reload\n",
    "\n",
    "# main: Имя файла Python без .py (main.py -> main)\n",
    "# app: Имя переменной в main.py, содержащей объект FastAPI (app = FastAPI())\n",
    "# --reload: Опция для автоматического перезапуска сервера при изменении кода"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Структура проекта\n",
    "\n",
    "*   **`.env`:** Конфигурация (URL базы данных).\n",
    "*   **`requirements.txt`:** Зависимости Python.\n",
    "*   **`database.py`:** Подключение к БД, функция `get_db`.\n",
    "*   **`models.py`:** Модели SQLAlchemy (структура таблиц).\n",
    "*   **`schemas.py`:** Схемы Pydantic (валидация, сериализация).\n",
    "*   **`main.py`:** Приложение FastAPI (эндпоинты, логика).\n",
    "*   **`README.md`:** Документация.\n",
    "*   **`lecture_notes.md`:** Теория (Markdown).\n",
    "*   **`lecture_notebook.ipynb`:** (Проблемный файл)\n",
    "*   **`lecture_notebook_v2.ipynb`:** (Проблемный файл)\n",
    "*   **`lecture_notebook_content.json`:** JSON-содержимое для ноутбука (этот файл)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. Взаимодействие компонентов (Жизненный цикл запроса)\n",
    "\n",
    "Рассмотрим пример запроса `POST /students/`:\n",
    "\n",
    "1.  **Клиент** → `POST /students/` с JSON\n",
    "2.  **Uvicorn** → **FastAPI**\n",
    "3.  **FastAPI** → Находит обработчик `create_student`\n",
    "4.  **FastAPI** + **Pydantic** → Валидирует JSON по схеме `StudentCreate`\n",
    "5.  **FastAPI** → Вызывает `get_db()` (из `database.py`)\n",
    "6.  `get_db()` → Создает сессию **SQLAlchemy**\n",
    "7.  **FastAPI** → Вызывает `create_student(student, db)`\n",
    "8.  `create_student` →\n",
    "    *   Создает модель `StudentModel` (**SQLAlchemy**)\n",
    "    *   `db.add()`, `db.commit()` → Отправляет `INSERT` в **PostgreSQL**\n",
    "    *   `db.refresh()` → Обновляет модель из БД\n",
    "    *   Возвращает модель `StudentModel`\n",
    "9.  **FastAPI** + **Pydantic** → Сериализует модель `StudentModel` в JSON по схеме `StudentSchema`\n",
    "10. **FastAPI** → Отправляет ответ 200 OK с JSON клиенту\n",
    "11. **FastAPI** → Закрывает сессию **SQLAlchemy** (через `get_db`) "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11" 
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
} 